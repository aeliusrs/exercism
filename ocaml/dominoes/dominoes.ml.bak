open Base

type dominoe = (int * int)

let rotate (x, y) = (y, x)

let can_connect a b = (snd a = fst b)

let check length lst =
  Int.equal (List.hd_exn lst |> fst) (List.last_exn lst |> snd) &&
  List.length lst = length


let find_connect hd lst =
  List.find lst ~f:(fun e -> can_connect hd e || can_connect hd (rotate e))
  |> function
    | None -> lst
    | Some e -> if can_connect hd e then [e] else [(rotate e)]

let rec build_chains acc lst =
  match lst with
  | [] -> acc
  | lst ->
      let find = find_connect (List.last_exn acc) lst in
      let pool =
        List.filter lst ~f:(fun e -> not (
          List.exists ~f:(fun x -> Poly.equal x e || Poly.equal (rotate x) e) find))
      in
      build_chains (acc @ find) pool

let chain = function
  | [] as lst -> Some lst
  | lst ->
      let ret = List.sort lst ~compare:(fun (x0, y0) (x1, y1) -> Int.compare (x0 + y0) (x1 + y1))
      |> function | (hd :: tl) -> build_chains [hd] tl | [] -> [] in
      match check (List.length lst) ret with
      | true  -> Some ret
      | false -> None

